import logging
import sqlite3
import secrets
import asyncio
from datetime import datetime, timedelta, timezone
from io import BytesIO
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    LabeledPrice,
    ReplyKeyboardMarkup
)
from telegram.ext import (
    _updater,
    Application,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    CallbackQueryHandler,
    PreCheckoutQueryHandler,
    filters
)

# –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è
TOKEN = "7749755571:AAE4qmU7G04BpVzddPMjkzN3dAO9tj7qqrU"
ADMIN_IDS = [2134434120, 6639580282]
VPN_DNS = "1.1.1.1, 8.8.8.8"
KEY_EXPIRATION_DAYS = 30
WG_SERVER_PUBLIC_KEY = "your_wg_pubkey"
SERVER_IP = "your.server.ip"
SUBSCRIPTION_PRICE = 20000
STARS_PER_SUBSCRIPTION = 50
REFERRAL_BONUS_DAYS = 7
MAX_DEVICES = 3

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ë–î
def init_db():
    with sqlite3.connect('vpn_keys.db') as conn:
        conn.execute('''
            CREATE TABLE IF NOT EXISTS users (
                user_id INTEGER PRIMARY KEY,
                key TEXT NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                expires_at TEXT
            )
        ''')

init_db()

# –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–∞
def generate_key():
    return secrets.token_urlsafe(24)

# –ö–ª–∞–≤–∏–∞—Ç—É—Ä—ã
user_keyboard = ReplyKeyboardMarkup([
    ["/getkey", "/dns", "/buy"],
    ["/support", "/myid", "/ref"],
    ["/devices", "/servers"]
], resize_keyboard=True)

admin_keyboard = ReplyKeyboardMarkup(
    [["/stats", "/allkeys"], ["/broadcast"]],
    resize_keyboard=True
)

# ================= –û–°–ù–û–í–ù–´–ï –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò =================

async def getkey(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user_id = update.effective_user.id
    try:
        with sqlite3.connect('vpn_keys.db') as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT key, expires_at FROM users WHERE user_id = ?', (user_id,))
            result = cursor.fetchone()

            if result and result[1]:
                expires_at = datetime.fromisoformat(result[1])
                if datetime.now(timezone.utc) < expires_at:
                    await update.message.reply_text(
                        f"‚úÖ –í–∞—à –∫–ª—é—á: {result[0]}\n"
                        f"‚è≥ –î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ: {expires_at.strftime('%d.%m.%Y %H:%M')}"
                    )
                    return

            new_key = generate_key()
            expires_at = datetime.now(timezone.utc) + timedelta(days=KEY_EXPIRATION_DAYS)
            cursor.execute('''
                INSERT OR REPLACE INTO users 
                (user_id, key, expires_at)
                VALUES (?, ?, ?)
            ''', (user_id, new_key, expires_at.isoformat()))
            conn.commit()

            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("WireGuard Config", callback_data="wg_config")],
                [InlineKeyboardButton("OpenVPN Config", callback_data="ovpn_config")]
            ])

            await update.message.reply_text(
                f"üéâ –ù–æ–≤—ã–π –∫–ª—é—á: `{new_key}`\n"
                f"‚è≥ –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è: {expires_at.strftime('%d.%m.%Y %H:%M')}\n\n"
                "üìé –í—ã–±–µ—Ä–∏—Ç–µ —Ç–∏–ø –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏:",
                reply_markup=keyboard,
                parse_mode='Markdown'
            )
    except Exception as e:
        logger.error(f"Error in getkey: {e}")
        await update.message.reply_text("üö´ –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞")

# ================= –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –§–£–ù–ö–¶–ò–ò =================

async def dns(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        f"üîß –†–µ–∫–æ–º–µ–Ω–¥—É–µ–º—ã–µ DNS-—Å–µ—Ä–≤–µ—Ä—ã:\n\n"
        f"‚Ä¢ Cloudflare: `1.1.1.1`\n"
        f"‚Ä¢ Google: `8.8.8.8`\n"
        f"‚Ä¢ AdGuard: `94.140.14.14`",
        parse_mode='Markdown'
    )

async def support(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "üõ† –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∞—è –ø–æ–¥–¥–µ—Ä–∂–∫–∞:\n\n"
        "‚Ä¢ Email: support@example.com\n"
        "‚Ä¢ Telegram: @tech_support"
    )

async def myid(update: Update, context: ContextTypes.DEFAULT_TYPE):
    user = update.effective_user
    await update.message.reply_text(
        f"üÜî –í–∞—à Telegram ID: `{user.id}`",
        parse_mode='Markdown'
    )

# ================= –ê–î–ú–ò–ù-–§–£–ù–ö–¶–ò–ò =================

async def stats(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    conn = sqlite3.connect('vpn_keys.db')
    cursor = conn.cursor()
    cursor.execute('SELECT COUNT(*) FROM users')
    total = cursor.fetchone()[0]
    conn.close()
    
    await update.message.reply_text(
        f"üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n"
        f"‚Ä¢ –í—Å–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {total}\n"
        f"‚Ä¢ –°—Ä–æ–∫ –¥–µ–π—Å—Ç–≤–∏—è –∫–ª—é—á–∞: {KEY_EXPIRATION_DAYS} –¥–Ω–µ–π"
    )

async def allkeys(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id not in ADMIN_IDS:
        return
    
    conn = sqlite3.connect('vpn_keys.db')
    cursor = conn.cursor()
    cursor.execute('SELECT user_id, key, expires_at FROM users')
    keys = cursor.fetchall()
    conn.close()
    
    response = "üîë –í—Å–µ –∞–∫—Ç–∏–≤–Ω—ã–µ –∫–ª—é—á–∏:\n\n"
    for user_id, key, expires_at in keys:
        response += f"üë§ {user_id}: `{key}`\n‚è≥ {expires_at}\n\n"
    
    await update.message.reply_text(response[:4000], parse_mode='Markdown')

# ================= –ö–û–ù–§–ò–ì–£–†–ê–¶–ò–ò VPN =================

async def generate_config(update: Update, context: ContextTypes.DEFAULT_TYPE, vpn_type: str):
    query = update.callback_query
    await query.answer()
    user_id = query.from_user.id
    
    try:
        with sqlite3.connect('vpn_keys.db') as conn:
            cursor = conn.cursor()
            cursor.execute('SELECT key FROM users WHERE user_id = ?', (user_id,))
            result = cursor.fetchone()
            
            if not result:
                await query.message.reply_text("‚ùå –°–Ω–∞—á–∞–ª–∞ –ø–æ–ª—É—á–∏—Ç–µ –∫–ª—é—á —á–µ—Ä–µ–∑ /getkey")
                return

            key = result[0]
            config = ""
            filename = ""
            
            if vpn_type == "WireGuard":
                config = f"""[Interface]
PrivateKey = {key}
Address = 10.0.0.{user_id % 254}/24
DNS = 1.1.1.1

[Peer]
PublicKey = {WG_SERVER_PUBLIC_KEY}
Endpoint = {SERVER_IP}:51820
AllowedIPs = 0.0.0.0/0"""
                filename = f"wg-{user_id}.conf"
                
            elif vpn_type == "OpenVPN":
                config = f"""client
dev tun
proto udp
remote {SERVER_IP} 1194
resolv-retry infinite
nobind
persist-key
persist-tun
<ca>
-----BEGIN CERTIFICATE-----
–í–ê–®_CA_–°–ï–†–¢–ò–§–ò–ö–ê–¢
-----END CERTIFICATE-----
</ca>
<key>
{key}
</key>"""
                filename = f"ovpn-{user_id}.ovpn"

            bio = BytesIO(config.encode())
            bio.name = filename
            await context.bot.send_document(
                chat_id=user_id,
                document=bio,
                caption=f"‚öôÔ∏è {vpn_type} –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è"
            )
    except Exception as e:
        logger.error(f"Config generation error: {e}")
        await query.message.reply_text("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–æ–Ω—Ñ–∏–≥–∞")

async def check_subscriptions(app: Application):
    """–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫"""
    try:
        with sqlite3.connect('vpn_keys.db') as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT user_id FROM users WHERE expires_at < ?", 
                         (datetime.now(timezone.utc).isoformat(),))
            
            for user_id, in cursor.fetchall():
                await app.bot.send_message(
                    user_id,
                    "‚ö†Ô∏è –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ 3 –¥–Ω—è! –ü—Ä–æ–¥–ª–∏—Ç–µ –µ—ë –∫–æ–º–∞–Ω–¥–æ–π /buy"
                )
    except Exception as e:
        logger.error(f"Subscription check error: {e}")

# ================= –ù–û–í–´–ï –§–£–ù–ö–¶–ò–ò ================= #

async def buy_subscription(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–ø–ª–∞—Ç–∞ –ø–æ–¥–ø–∏—Å–∫–∏ —á–µ—Ä–µ–∑ –ÆKassa"""
    chat_id = update.message.chat_id
    title = "VPN Premium –ø–æ–¥–ø–∏—Å–∫–∞"
    description = "–î–æ—Å—Ç—É–ø –∫ VPN –Ω–∞ 1 –º–µ—Å—è—Ü"
    payload = "subscription"
    currency = "RUB"
    prices = [LabeledPrice("–ú–µ—Å—è—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", SUBSCRIPTION_PRICE)]

    await context.bot.send_invoice(
        chat_id,
        title,
        description,
        payload,
        "YOUR_PAYMENT_TOKEN",
        currency,
        prices
    )

async def referral_system(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–†–µ—Ñ–µ—Ä–∞–ª—å–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞"""
    user_id = update.effective_user.id
    ref_link = f"https://t.me/{context.bot.username}?start=ref{user_id}"
    
    await update.message.reply_text(
        f"üéÅ –ü—Ä–∏–≥–ª–∞—Å–∏—Ç–µ –¥—Ä—É–∑–µ–π –∏ –ø–æ–ª—É—á–∞–π—Ç–µ +{REFERRAL_BONUS_DAYS} –¥–Ω–µ–π –∑–∞ –∫–∞–∂–¥–æ–≥–æ!\n\n"
        f"–í–∞—à–∞ —Å—Å—ã–ª–∫–∞:\n{ref_link}"
    )

async def device_management(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞–º–∏"""
    # –õ–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–π
    await update.message.reply_text(
        "üì± –ê–∫—Ç–∏–≤–Ω—ã–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–∞:\n"
        "1. Android [IP: 192.168.1.101]\n"
        "2. Windows [IP: 192.168.1.102]\n\n"
        "‚ùå –î–ª—è –æ—Ç–∫–ª—é—á–µ–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /revoke <–Ω–æ–º–µ—Ä>"
    )

async def server_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–í—ã–±–æ—Ä —Å–µ—Ä–≤–µ—Ä–∞"""
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üá∑üá∫ –ú–æ—Å–∫–≤–∞", callback_data="server_ru")],
        [InlineKeyboardButton("üá©üá™ –ë–µ—Ä–ª–∏–Ω", callback_data="server_de")],
        [InlineKeyboardButton("üá∫üá∏ –ù—å—é-–ô–æ—Ä–∫", callback_data="server_us")]
    ])
    
    await update.message.reply_text(
        "üåç –í—ã–±–µ—Ä–∏—Ç–µ —Å–µ—Ä–≤–µ—Ä:",
        reply_markup=keyboard
    )

# ==================  PAYMENT  ================== #

async def buy(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ú–µ–Ω—é –≤—ã–±–æ—Ä–∞ —Å–ø–æ—Å–æ–±–∞ –æ–ø–ª–∞—Ç—ã"""
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üí≥ –û–ø–ª–∞—Ç–∞ –∫–∞—Ä—Ç–æ–π", callback_data="pay_card")],
        [InlineKeyboardButton("‚≠êÔ∏è Telegram Stars", callback_data="pay_stars")]
    ])
    
    await update.message.reply_text(
        "üéÅ –í—ã–±–µ—Ä–∏—Ç–µ —Å–ø–æ—Å–æ–± –æ–ø–ª–∞—Ç—ã:",
        reply_markup=keyboard
    )

async def handle_payment_choice(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ –æ–ø–ª–∞—Ç—ã"""
    query = update.callback_query
    await query.answer()
    
    if query.data == "pay_card":
        await send_card_invoice(query)
    elif query.data == "pay_stars":
        await send_stars_invoice(query)

async def send_card_invoice(query):
    """–ò–Ω–≤–æ–π—Å –¥–ª—è –æ–ø–ª–∞—Ç—ã –∫–∞—Ä—Ç–æ–π"""
    await query.message.reply_invoice(
        title="VPN Premium (–ö–∞—Ä—Ç–∞)",
        description="–î–æ—Å—Ç—É–ø –∫ VPN –Ω–∞ 1 –º–µ—Å—è—Ü",
        payload="card_payment",
        provider_token="YOUR_CARD_PROVIDER_TOKEN",  # –¢–æ–∫–µ–Ω –¥–ª—è –∫–∞—Ä—Ç
        currency="RUB",
        prices=[LabeledPrice("–ú–µ—Å—è—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", 49000)],
        need_phone_number=False,
        need_email=False
    )

async def send_stars_invoice(query):
    """–ò–Ω–≤–æ–π—Å –¥–ª—è –æ–ø–ª–∞—Ç—ã Stars"""
    await query.message.reply_invoice(
        title="VPN Premium (Stars)",
        description="–î–æ—Å—Ç—É–ø –∫ VPN –Ω–∞ 1 –º–µ—Å—è—Ü",
        payload="stars_payment",
        provider_token="YOUR_STARS_PROVIDER_TOKEN",  # –¢–æ–∫–µ–Ω –¥–ª—è Stars
        currency="XTR",
        prices=[LabeledPrice("–ú–µ—Å—è—á–Ω–∞—è –ø–æ–¥–ø–∏—Å–∫–∞", 50 * 100)],  # 50 Stars
        need_phone_number=False,
        need_email=False
    )

async def precheckout(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ –ø–ª–∞—Ç–µ–∂–∞"""
    query = update.pre_checkout_query
    await query.answer(ok=True)

async def successful_payment(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """–û–±—Ä–∞–±–æ—Ç–∫–∞ —É—Å–ø–µ—à–Ω–æ–≥–æ –ø–ª–∞—Ç–µ–∂–∞"""
    user_id = update.effective_user.id
    payment = update.message.successful_payment
    
    # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ä–æ–∫ –ø–æ–¥–ø–∏—Å–∫–∏
    expires_at = datetime.now(timezone.utc) + timedelta(days=30)
    
    conn = sqlite3.connect('vpn_keys.db')
    cursor = conn.cursor()
    cursor.execute('''
        UPDATE users 
        SET expires_at = ? 
        WHERE user_id = ?
    ''', (expires_at.isoformat(), user_id))
    conn.commit()
    conn.close()
    
    await update.message.reply_text("‚úÖ –ü–æ–¥–ø–∏—Å–∫–∞ —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞!")

# ================= –ó–ê–ü–£–°–ö –ë–û–¢–ê ================= #

async def check_subscriptions(app: Application):
    """–ï–∂–µ–¥–Ω–µ–≤–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–ø–∏—Å–æ–∫"""
    try:
        with sqlite3.connect('vpn_keys.db') as conn:
            cursor = conn.cursor()
            cursor.execute("SELECT user_id FROM users WHERE expires_at < ?", 
                         (datetime.now(timezone.utc).isoformat(),))
            
            for user_id, in cursor.fetchall():
                await app.bot.send_message(
                    user_id,
                    "‚ö†Ô∏è –í–∞—à–∞ –ø–æ–¥–ø–∏—Å–∫–∞ –∏—Å—Ç–µ–∫–∞–µ—Ç —á–µ—Ä–µ–∑ 3 –¥–Ω—è! –ü—Ä–æ–¥–ª–∏—Ç–µ –µ—ë –∫–æ–º–∞–Ω–¥–æ–π /buy"
                )
    except Exception as e:
        logger.error(f"Subscription check error: {e}")

async def main() -> None:
    application = Application.builder().token(TOKEN).build()

    # –ü–ª–∞–Ω–∏—Ä–æ–≤—â–∏–∫ –∑–∞–¥–∞—á
    scheduler = AsyncIOScheduler()
    scheduler.add_job(
        check_subscriptions,
        IntervalTrigger(days=1),
        args=[application]
    )
    scheduler.start()

    # –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
    handlers = [
        CommandHandler("start", start),
        CommandHandler("getkey", getkey),
        CommandHandler("dns", dns),
        CommandHandler("support", support),
        CommandHandler("stats", stats),
        CommandHandler("allkeys", allkeys),
        CommandHandler("myid", myid),
        CommandHandler("buy", buy),
        CommandHandler("ref", referral_system),
        CommandHandler("devices", device_management),
        CommandHandler("servers", server_selection),
        CallbackQueryHandler(button_handler),
        CallbackQueryHandler(handle_payment_choice, pattern=r"^(pay_card|pay_stars)$"),
        PreCheckoutQueryHandler(precheckout),
        MessageHandler(filters.SUCCESSFUL_PAYMENT, successful_payment),
        MessageHandler(filters.TEXT & ~filters.COMMAND, start)
    ]

    for handler in handlers:
        application.add_handler(handler)

    await application.run_polling()

if __name__ == "__main__":
    asyncio.run(main())